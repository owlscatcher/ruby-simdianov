# Быстрый старт

## Соглашения

В Ruby опускаются все необязательные элементы (`()`, `;`), `;` ставят только в том случае, если требуется расположить несколько вызовов метода на одной строке, но так делать не приниято, пример:

```ruby
# Правильно
puts 'Эрнесто, говорите!'
puts 'Да, Ганс?'

# Неправильно
puts 'Эрнесто?'; puts 'Да, Ганс?'
```

На соглашениях строится львиная доля удобства Ruby и Ruby on Rails, их соблюдение является обязательным (несоблюдение не приведет к явным ошибкам, но это не приветствуется).

## Комментарии

Комментарии в Ruby могут быть однострочными и многострочными.

```ruby
# Пример однострочного комментария
puts 'Эта строка будет выведена в STDOUT' # А эта нет
```

```ruby
==begin
А это пример многострочного комментария
Код из этого блока не будет выполнен

puts 'В том числе и этот тоже!'

==end

puts 'А этот код уже исполнится'
```

Также есть такой тип комментариев, как `__END__`

```ruby
puts 'Вывод - 1'
puts 'Вывод - 2'

__END__
Все, что расположено ниже __END__ выведено не будет.
```

## Элементы языка

**Ключевые слова** -- слова, зарезервированные для использования в Ruby, например `def`, `end`, `class` и т.д.
**Переменные** -- именованная область в памяти. К этой области в памяти мы можем обращаться через имя переменной, например:

```ruby
magic_power = 5

puts magic_power #  => 5
```

Переменные именуются в соответствии с соглашением в _snake_case_.

**Константы** -- также именованная область в памяти, как и переменная. В Ruby это формальности и в отличии от, например, JavaScript или С# значение константы можно изменить. Обычно имя константы пишут с заглавной буквы, например `RUBY_VERSION`.
**Объект** -- в Ruby почти всё является объектом, с характерным для объекта поведением.

```ruby
2.zero? # => false
2.between? 0, 4 # => true

[1, 2, 3].length # => 3
```

Каждый объект наследуется от `BasicObject`, это легко выяснить:

```ruby
Object.superclass # => BasicObject

Class.superclass # => Module
Module.superclass # => Object
```

**Классы, методы и модули** -- Модуль и Класс это специальный объект, который определяет поведение объекта. Именуются всегда в _CamelCase_. Чтобы создать новый экземпляр класса, нужно воспользоваться методом `new`:

```ruby
arr = Array.new
```

```ruby
# Создание своего класса

class Greeting
  def say_hello
    puts 'Hello, dude!'
  end
end

grt = Greeting.new
grt.say_hello # => Hello, dude!
```

Модули же в Ruby похожи на `namespace` в C# и служат для организации пространства имен. Не предоставляют функционал создания своих экземпляров.

```ruby
module ExtraSuperDuperModule
  class Class1
    def say_hello
      puts 'Hello, dude!'
    end
  end

  class Class2
  end
end

grt = ExtraSuperDuperModule::Class1.new
grt.say_hello # => Hello, dude!
```

Метод же это просто именованная последовательность действий. Объявляется ключевым словом `def`, именуется в _snake_case_. Примером может быть метод `say_hello` из примера выше. Метод может принимать параметры, если параметр 1, не обязательно указывать скобки, но как правило во многих соглашениях и линтерах все же скобки ставят:

```ruby

def say_my_name(name)
  puts name
end

def say_my_name name
  puts name
end
```

Эти объявления эквивалентны.

**Операторы** -- по сути этот просто такие же методы. Операторы производят арифметические действия, сравнения и т.д.: `+`, `-`, `*`, `/`, `&`.

```ruby
5 + 2 # => 7
5.+ 2 # => 7
```

## Вывод в STDOUT и экранирование в Ruby

Для вывода в стандартный поток существует метод `puts`:

```ruby
puts('Say', 'My', 'Name', 3)

# => Say
# => My
# => Name
# => 3
```

`puts 3` и `puts '3'` дадут одинаковый вывод 3, для отладки можно использовать `inspect`:

```ruby
puts 3.inspect # => 3
puts '3'.inspect # => "3"
```

В ruby существует короткий эквивалент этой конструкции `p`:

```ruby
puts '3'.inspect # => "3"
p 3 # => "3"
```

Для экранирования при выводе испльзуется `\`:

```ruby
puts 'Owls\' Catcher' # => Owls' Catcher
```

Как и в C# работают последовательности `\n`, `\r`, `\t`.
